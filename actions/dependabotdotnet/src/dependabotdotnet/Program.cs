if (args is { Length: 0 } || args[0] is not string path)
{
    WriteLine("Must specify a repo root directory as input");
    return 1;
}

string destinationFilePath = args is { Length: 2 } 
    ? args[1] 
    : $".github{Path.AltDirectorySeparatorChar}dependabot.yml";

static void WriteLineToBufferAndOutput(StringBuilder buffer, string content)
{
    buffer.AppendLine(content);
    WriteLine(content);
}

StringBuilder buffer = new();

// yaml top-matter
string topMatter = """
    # generated by dependadotnet
    # https://github.com/dotnet/core/tree/main/samples/dependadotnet
    version: 2
    updates:
    """;

WriteLineToBufferAndOutput(buffer, topMatter);

/* Generate the following pattern for each project file:

  Note: Wednesday was chosen for quick response to .NET patch Tuesday updates

- package-ecosystem: ""nuget""
  directory: ""/"" #projectfilename
  schedule:
      interval: ""weekly""
      day: ""wednesday""
  open-pull-requests-limit: 5
*/

string packageFilePath = "packages-ignore.json";
Dictionary<string, string[]> packageIgnore = await GetPackagesInfoAsync(packageFilePath);

const string packageReference = @"PackageReference Include=""";
const string targetFrameworkStart = "<TargetFramework>";
const string targetFrameworkEnd = "</TargetFramework>";
string dotnetDir = $"**/{Path.AltDirectorySeparatorChar}.dotnet";

Matcher projectMatcher = new();
projectMatcher.AddIncludePatterns(
    new[] { "**/*.csproj", "**/*.fsproj", "**/*.vbproj" });
projectMatcher.AddExclude(dotnetDir);

var patternMatchingResult = projectMatcher.Execute(
    new DirectoryInfoWrapper(
        new DirectoryInfo(path)));

if (patternMatchingResult.HasMatches)
{
    foreach (var fileMatch in patternMatchingResult.Files)
    {
        string file = Path.Combine(path, fileMatch.Path);
        string filename = Path.GetFileName(file);
        string? parentDir = Path.GetDirectoryName(file);
        string relativeDir = parentDir?[path.Length..].Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar) ?? Path.AltDirectorySeparatorChar.ToString();
        string? targetFramework = null;
        bool match = false;
        List<PackageIgnoreMapping> mappings = new();
        foreach (string content in File.ReadLines(file))
        {
            if (targetFramework is null && TryGetTargetFramework(content, out targetFramework))
            {
            }

            if (PackageReferenceVersionRegex().IsMatch(content))
            {
                match = true;

                if (TryGetPackageName(content, out string? packageName) &&
                    packageIgnore.TryGetValue($"{packageName}_{targetFramework}", out string[]? ignore))
                {
                    mappings.Add(new(packageName, ignore));
                }

                break;
            }
        }

        if (!match)
        {
            continue;
        }

        WriteLineToBufferAndOutput(buffer, $"""
              - package-ecosystem: "nuget"
                directory: "{relativeDir}" #{filename}
                schedule:
                  interval: "weekly"
                  day: "wednesday"
                open-pull-requests-limit: 5
            """);

        if (mappings.Count is 0)
        {
            continue;
        }

        /* Format:
    ignore:
     - dependency-name: "Microsoft.AspNetCore.Mvc.NewtonsoftJson"
       versions: ["5.*"]        
        */

        WriteLineToBufferAndOutput(buffer, "    ignore:");

        foreach (PackageIgnoreMapping mapping in mappings)
        {
            WriteLineToBufferAndOutput(buffer, $"""
                      - dependency-name: ""{mapping.PackageName}""
                       versions: {PrintArrayAsYaml(mapping.Ignore)}
                """);
        }
    }
}

if (buffer is { Length: > 118 /* top matter length */ })
{
    var contents = buffer.ToString();
    await File.WriteAllTextAsync(destinationFilePath, contents);
}

return 0;

static bool TryGetTargetFramework(
    string content,
    [NotNullWhen(true)] out string? targetFramework)
{
    targetFramework = null;
    int start = content.IndexOf(targetFrameworkStart);
    if (start is -1)
    {
        return false;
    }

    int end = content.IndexOf(targetFrameworkEnd);
    if (end is -1 || end < start)
    {
        return false;
    }

    int startOfTFM = start + targetFrameworkStart.Length;
    targetFramework = content[startOfTFM..end];

    return targetFramework.StartsWith("net");
}

static bool TryGetPackageName(
    string content, 
    [NotNullWhen(true)] out string? packageName)
{
    packageName = null;
    int start = content.IndexOf(packageReference);
    if (start < 0)
    {
        return false;
    }

    int startOfPackageName = start + packageReference.Length;
    int endOfPackageName = content.AsSpan(startOfPackageName).IndexOf('"');
    if (endOfPackageName is 0)
    {
        return false;
    }

    packageName = content.Substring(startOfPackageName, endOfPackageName);
    return true;
}

static async Task<Dictionary<string, string[]>> GetPackagesInfoAsync(string path)
{
    var json = await File.ReadAllTextAsync(path);
    JsonSerializerOptions options = new(JsonSerializerDefaults.Web);

    PackageInfoSet? packages = JsonSerializer.Deserialize<PackageInfoSet>(json, options);
    return packages switch
    {
        null => throw new IOException("Could not download packages information"),
        _ => packages.Packages
                .SelectMany(package => package.Mapping.Select(mapping => (Key: $"{package.Name}_{mapping.TargetFramework}", Value: mapping.Ignore)))
                .ToDictionary(_ => _.Key, _ => _.Value)
    };
}

static string PrintArrayAsYaml(string[] array)
{
    StringBuilder buffer = new();
    buffer.Append('[');
    for (int i = 0; i < array.Length; i++)
    {
        buffer.Append($@"""{array[i]}""");

        if (i + 1 < array.Length)
        {
            buffer.Append(", ");
        }
    }
    buffer.Append(']');

    return buffer.ToString();
}

record PackageInfoSet(PackageInfo[] Packages);

readonly record struct PackageInfo(string Name, PackageTargetFrameworkIgnoreMapping[] Mapping);
readonly record struct PackageTargetFrameworkIgnoreMapping(string TargetFramework, string[] Ignore);
readonly record struct PackageIgnoreMapping(string PackageName, string[] Ignore);

static partial class Program
{
    [GeneratedRegex("PackageReference.*Version=\"[0-9]")]
    private static partial Regex PackageReferenceVersionRegex();

    private static readonly HttpClient s_client = new();
}